{"name":"Cosmic","tagline":"COSmIC is a set of \"Composition Operators for Sensing Infrastructure\"","body":"\r\nCOSmIC framework\r\n================\r\n\r\nThe **COSmIC** (Composition Operators for Sensing InfrastuCture) is a tool aimed to support different users on a shared System Information by generating code deployed on each level composing the sensors network.\r\n\r\nThis short *HOWTO* is intended to give a brief overview of the framework and to provide the minimal material to understand how it works.\r\n\r\nArchitecture\r\n------------\r\n\r\nThis framework is organised in different packages:\r\n\r\n* fr.unice.modalis.cosmic.**actions**: actions modelisation \r\n* fr.unice.modalis.cosmic.**algo**: algorithms used to compose data collection behaviors (contains the COSmIC operators)\r\n* fr.unice.modalis.cosmic.**conveter**: code generators\r\n* fr.unice.modalis.cosmic.**core**: data structure used to build a user behavior\r\n* fr.unice.modalis.cosmic.**exceptions**: exceptions handled by the framework\r\n* fr.unice.modalis.cosmic.**scenario**: pre-defined scenarios which can be used to model basic user behaviors\r\n\r\nHow-to: Build a data collection behavior?\r\n-------------------------------------------\r\n\r\nA data collection behavior is defined as a simplification of classical timed automaton. It uses :\r\n\r\n* Nodes: Correspond to the automaton' states on which, actions can be attached\r\n* Transitions: Model the transition relation between two nodes. Theses transitions are conditioned by a time-to-wait (TickCondition) value before being parsed.\r\n\r\nTo be valid, a behavior **MUST** be Cyclic, Deterministic and only contain transitions conditioned by a TickCondition. \r\n\r\nThe code bellow build a blank behavior (i.e. no actions performed) with 3 nodes and a 5 seconds period:\r\n\r\n\r\n```scala\r\n  /* Define nodes modeling states */\r\n  val n1 = new Node(\"A\")\r\n  val n2 = new Node(\"B\")\r\n  val n3 = new Node(\"C\")\r\n\r\n  /* Define transitions */\r\n  val t1 = new Transition(n1,n2, new TickCondition(1)) // Wait 1s\r\n  val t2 = new Transition(n2,n3, new TickCondition(2)) // Wait 2s\r\n  val t3 = new Transition(n3,n1, new TickCondition(2)) // Wait 2s\r\n\r\n  /* Build behavior with n1 as entry point */\r\n  val b = new Behavior(n1).addNodes(List(n1,n2,n3)).addTransitions(List(t1,t2,t3))\r\n```\r\n\r\nHow-to: Use actions in a data collection behavior?\r\n---------------------------------------------------\r\n\r\nThe COSmIC framework provides 5 kinds of actions (see in fr.unice.modalis.cosmic.actions.unit):\r\n\r\n* ReadSensorAction: Read a value from a given sensor\r\n* InitSerialAction: Initialize a serial port\r\n* ReadSerialAction: Read a value on the serial port\r\n* WriteSerialAction: Write a value on the serial port \r\n* EmitAction: Emit a value to an external endpoint\r\n\r\nSome of theses actions returns results which can be saved in:\r\n\r\n* InitSerialResult: Store the reference to a serial port\r\n* ReadSensorResult: Store the sensor read value\r\n* ReadSerialResult: Store the value read on the serial port\r\n\r\nThe code bellow presents how to:\r\n\r\n1. Read value from a sensor\r\n2. Send this value to the bridge\r\n3. Emit the value to an external endpoint\r\n\r\n```scala\r\n  // Define result variables\r\n  val readSensorResult = new ReadSensorResult()\r\n  val refSerial = new InitSerialResult()\r\n  val readSerialResult = new ReadSerialResult()\r\n\r\n  // Define actions\r\n  \r\n  // Read value from a sensor\r\n  val readSensorAction = new ReadSensorAction(\"tempSensor\", readSensorResult)\r\n  // Send this value to the bridge\r\n  val sendSerialAction = new WriteSerialAction(readSensorResult)\r\n  \r\n  // Bridge serial init and read\r\n  val initSerialAction = new InitSerialAction(\"COM1\", refSerial)\r\n  val readSerialValue = new ReadSerialAction(refSerial, readSerialResult)\r\n  \r\n  // Emit value\r\n  val emitAction = new EmitAction(readSerialResult, \"http://myserver\", 8080)\r\n```\r\n\r\n*NB: In a further version, bridge serial initialisation and reading would be encapsulate in a SendToBridgeAction class.*\r\n\r\nTheses action can be attached to *nodes* thanks to the `addaction(a:Action)` method.\r\n\r\n```scala\r\n  /* ... */\r\n  val node = new Node(\"myNode\").addAction(readSensorAction)\r\n                               .addAction(sendSerialAction)\r\n                               .addAction(initSerialAction)\r\n                               .addAction(readSerialValue)\r\n                               .addAction(emitAction)\r\n  /* ... */\r\n```\r\n\r\nHow-to: Define guards on actions?\r\n---------------------------------\r\n\r\nThe COSmIC framework provides also a guard mechanism. We define a guard as a boolean equation which allow or disallow the action execution according to the current context.\r\n\r\nGuards are represented under a boolean equation of constraints. The COSmIC framework allows to model the following constraints:\r\n* TimeConstraint: an action can be executed only in a given time set)\r\n* ValueConstraint: the action execution depends on the comparison between a value and a threshold\r\n\r\n*NB: The code generator provided in the COSmIC Framework only handle ValueConstraint for the moment*\r\n\r\nDifferent constraints can be mixed together to build a boolean equation with the following predicates:\r\n* ANDPredicate: represents `constraint1 ∧ constraint2`\r\n* ORPredicate: represents `constraint1 || constraint2`\r\n* NOTPredicate: represents `~constraint`\r\n\r\nThe results of xPredicate statements are also *guards* which can be composed with others.\r\n\r\nIn the example presented bellow, we re-use the previous action definition to a model a temperature collect behavior only if the measure is lower than 20° and occurs during work time:\r\n\r\n```scala\r\n  /* ... */\r\n  \r\n  // Define result variables\r\n  ...\r\n  \r\n  // Define actions\r\n  ...\r\n  val emitAction = new EmitAction(readSerialResult, \"http://myserver\", 8080)\r\n                        .addGuard(new ANDPredicate(\r\n                            new ValueConstraint(readSerialValue, 20, \"<\"), \r\n                            new TimeConstraint(\"08:00\",\"18:00\"))\r\n                            )\r\n```\r\n\r\nHow-to: Compose two (or more) behaviors?\r\n---------------------------------------\r\n**PRE-CONDITION:** Behaviors must be valid before applying the COSmIC algebra (*i.e.* **Cyclic**, **Deterministic** and **only contain transitions conditioned by a TickCondition**)\r\n\r\nAll algorithms used during the composition process are located in the **fr.unice.modalis.cosmic.algo.Transformation** object.\r\n\r\nThis class provides in particular the `+`-operator (compose(b1:Behavior,b2:Behavior):Behavior) to compose two behaviors. As an example, we define the well-known Alice & Bob behaviors and we compose them:\r\n\r\n```scala\r\n  val refRead1 = new ReadSensorResult()\r\n  val n1 = new Node(\"Alice\").addAction(new ReadSensorAction(\"temp\", refRead1))\r\n                            .addAction(new WriteSerialAction(refRead1, \"Alice\"))\r\n  val t1 = new Transition(n1, n1, new TickCondition(3))\r\n  val alice = new Behavior(n1).addTransition(t1) //Alice behavior\r\n\r\n  val refRead2 = new ReadSensorResult()\r\n  val n2 = new Node(\"Bob\").addAction(new ReadSensorAction(\"temp\", refRead2))\r\n                          .addAction(new WriteSerialAction(refRead2, \"Bob\"))\r\n  val t2 = new Transition(n2, n2, new TickCondition(2))\r\n  val bob = new Behavior(n2).addTransition(t2) // Bob behavior\r\n```\r\n\r\nThe validity of Alice and Bob behaviors can be asserted with the `isCorrectBehavior(b: Behavior)` method in the **fr.unice.modalis.cosmic.algo.Utils** object:\r\n\r\n```scala\r\n  assert(Utils.isCorrectBehavior(alice) && Utils.isCorrectBehavior(bob) == true)\r\n```\r\n\r\nIf the assertion is true, Alice and Bob behaviors can be composed together. The COSmIC framework provides syntactic sugar for composition:\r\n\r\n```scala\r\n// Without syntaxic sugar\r\nval composed = Transformation.compose(alice, bob)\r\n// With syntaxic sugar\r\n val composed = alice + bob\r\n```\r\n\r\nHow-to: Deploy a behavior on the sensor network?\r\n------------------------------------------------\r\n\r\nThe COSmIC framework provides code generators for sensor platforms and bridges. In this first version, we provide an Arduino generator (Wiring) and Raspberry Pi generator (Python). \r\n\r\nThe deployment process is the following:\r\n\r\n1. Compose the user collect behaviors\r\n2. Slice this composed behavior into two sub-behavior : (sensor platform behavior, bridge behavior)\r\n3. Forward the Sensor platform behavior (time synchronization is performed on the bridge)\r\n4. Minimize the Sensor platform behavior\r\n5. Generate code for the sensor platform behavior and the bridge behavior\r\n\r\n```scala\r\n/* Alice and Bob behaviors were defined previously */\r\n  val composed = alice + bob // Step 1\r\n\r\n  val (spBehavior, brBehavior) = Transformation.decompose(composed) // Step 2\r\n\r\n  val forwardedSP = Transformation.forward(spBehavior) // Step 3\r\n  \r\n  val minimizedSP = Transformation.minimize(forwardedSP) // Step 4\r\n  \r\n  ToSensorPlatform(minimizedSP) // Step 5 : generate Wiring code for Arduino\r\n  ToBridge(brBehavior) // Step 5 : generate Python code for Raspberry\r\n```\r\n\r\nA sugar syntactic trick allows the user to abstract this process:\r\n\r\n```scala\r\n  val composed = alice + bob // Step 1\r\n\r\n  val (spBehavior, brBehavior) = composed.deploy() //Step 2,3,4\r\n\r\n  ToSensorPlatform(spBehavior) // Step 5 : generate Wiring code for Arduino\r\n  ToBridge(brBehavior) // Step 5 : generate Python code for Raspberry\r\n```\r\n\r\nVideo demonstration\r\n-------------------\r\n\r\nThis video presents a practical application of the COSmIC framework. We perform the following operations: \r\n- Behavior definition\r\n- Behavior composition\r\n- Behavior decomposition\r\n- Deployment process\r\n\r\n[![COSmIC framework presentation](http://img.youtube.com/vi/hYpVEDyy02M/0.jpg)](http://www.youtube.com/watch?v=hYpVEDyy02M)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}